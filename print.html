<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rustecal Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rustecal Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><code>rustecal</code> is a safe and idiomatic Rust wrapper for <a href="https://github.com/eclipse-ecal/ecal">Eclipse eCAL</a>, designed for high-performance interprocess communication (IPC) in robotics, automotive, and embedded systems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<h2 id="rust-toolchain"><a class="header" href="#rust-toolchain">Rust Toolchain</a></h2>
<ul>
<li>Rust &gt;= 1.70</li>
<li>cargo, rustc</li>
</ul>
<h2 id="llvm--libclang-required-for-bindgen"><a class="header" href="#llvm--libclang-required-for-bindgen">LLVM + libclang (required for <code>bindgen</code>)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Install</th></tr></thead><tbody>
<tr><td>Windows</td><td><code>choco install llvm</code> or <a href="https://github.com/llvm/llvm-project/releases">LLVM releases</a></td></tr>
<tr><td>Linux</td><td><code>sudo apt install build-essential llvm-dev clang libclang-dev</code></td></tr>
</tbody></table>
</div>
<h3 id="environment-variable-for-bindgen-windows-only"><a class="header" href="#environment-variable-for-bindgen-windows-only">Environment Variable for Bindgen (Windows only)</a></h3>
<pre><code class="language-powershell">$env:LIBCLANG_PATH = "C:\Program Files\LLVM\bin"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecal-library-installation"><a class="header" href="#ecal-library-installation">eCAL Library Installation</a></h1>
<p><code>rustecal</code> is built on the eCAL v6 API and is not compatible with earlier eCAL v5 releases. General instructions for installation can be found <a href="https://eclipse-ecal.github.io/ecal/stable/getting_started/setup.html">here</a>.</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<ul>
<li>Install <a href="https://github.com/eclipse-ecal/ecal/releases">eCAL</a></li>
<li>Set the environment variable:</li>
</ul>
<pre><code class="language-powershell">$env:ECAL_HOME = "C:\eCAL"
</code></pre>
<p>Expected structure:</p>
<pre><code>%ECAL_HOME%/
├── include/ecal_c/
└── lib/ecal_core_c.lib
</code></pre>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<p>Install system-wide from source or package. Headers and libraries should be in:</p>
<ul>
<li><code>/usr/include/ecal_c/</code> or <code>/usr/local/include/ecal_c/</code></li>
<li><code>/usr/lib</code> or <code>/usr/local/lib</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h1>
<p>This workspace is organized into several purpose-specific crates to provide a modular, maintainable API for eCAL:</p>
<div class="table-wrapper"><table><thead><tr><th>Crate</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rustecal</code></td><td><strong>Meta-crate</strong>: re-exports core, pub/sub, and service APIs via feature flags (<code>pubsub</code>, <code>service</code>)</td></tr>
<tr><td><code>rustecal-core</code></td><td>Core lifecycle management, logging, monitoring, error handling, and shared type definitions</td></tr>
<tr><td><code>rustecal-pubsub</code></td><td>Typed and untyped Publisher/Subscriber API</td></tr>
<tr><td><code>rustecal-service</code></td><td>RPC service server &amp; client API</td></tr>
<tr><td><code>rustecal-sys</code></td><td>Low-level FFI bindings to the eCAL C API</td></tr>
<tr><td><code>rustecal-types-string</code></td><td>Helper: UTF-8 string message wrapper for typed pub/sub</td></tr>
<tr><td><code>rustecal-types-bytes</code></td><td>Helper: raw byte vector message wrapper</td></tr>
<tr><td><code>rustecal-types-protobuf</code></td><td>Helper: Protobuf message wrapper (using <code>prost</code>)</td></tr>
<tr><td><code>rustecal-types-serde</code></td><td>Helper: Serde JSON/CBOR/MessagePack message wrappers for typed pub/sub</td></tr>
<tr><td><code>rustecal-samples</code></td><td>Example binaries demonstrating pub/sub, RPC, monitoring, and logging</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="supported-message-types"><a class="header" href="#supported-message-types">Supported Message Types</a></h1>
<ul>
<li><code>BytesMessage</code> – Arbitrary binary data (<code>rustecal-types-bytes</code>)</li>
<li><code>StringMessage</code> – UTF-8 encoded strings (<code>rustecal-types-string</code>)</li>
<li><code>ProtobufMessage&lt;T&gt;</code> – Protobuf messages (<code>rustecal-types-protobuf</code>)</li>
<li><code>JsonMessage&lt;T&gt;</code> – JSON-serialized Serde types (<code>rustecal-types-serde</code>)</li>
<li><code>CborMessage&lt;T&gt;</code> – CBOR-serialized Serde types (<code>rustecal-types-serde</code>)</li>
<li><code>MsgpackMessage&lt;T&gt;</code> – MessagePack-serialized Serde types (<code>rustecal-types-serde</code>)</li>
</ul>
<p>Each type is provided via a dedicated crate to avoid pulling unnecessary dependencies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>Code samples for using rustecal.</p>
<h2 id="publish--subscribe"><a class="header" href="#publish--subscribe">Publish / Subscribe</a></h2>
<ul>
<li><a href="examples/string.html">String Messages</a></li>
<li><a href="examples/binary.html">Binary Messages</a></li>
<li><a href="examples/protobuf.html">Protobuf Messages</a></li>
<li><a href="examples/json.html">JSON Messages</a></li>
</ul>
<h2 id="service-client--server"><a class="header" href="#service-client--server">Service Client / Server</a></h2>
<ul>
<li><a href="examples/service_server.html">Mirror Server</a></li>
<li><a href="examples/service_client.html">Mirror Client</a></li>
</ul>
<h2 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h2>
<ul>
<li><a href="examples/monitoring.html">Monitoring Snapshot</a></li>
</ul>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<ul>
<li><a href="examples/logging.html">Logging Snapshot</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-message-example"><a class="header" href="#binary-message-example">Binary Message Example</a></h1>
<h2 id="publisher"><a class="header" href="#publisher">Publisher</a></h2>
<pre><pre class="playground"><code class="language-rust">use rustecal::{Ecal, EcalComponents, TypedPublisher};
use rustecal::pubsub::publisher::Timestamp;
use rustecal_types_bytes::BytesMessage;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Ecal::initialize(Some("blob publisher"), EcalComponents::DEFAULT, None)?;

    let publisher = TypedPublisher::&lt;BytesMessage&gt;::new("blob")?;

    let mut counter = 0u8;
    while Ecal::ok() {
        let buf = vec![counter; 1024];
        counter = counter.wrapping_add(1);

        let message = BytesMessage { data: buf.into() };
        publisher.send(&amp;message, Timestamp::Auto);

        std::thread::sleep(std::time::Duration::from_millis(500));
    }

    Ecal::finalize();
    Ok(())
}</code></pre></pre>
<h2 id="subscriber"><a class="header" href="#subscriber">Subscriber</a></h2>
<pre><pre class="playground"><code class="language-rust">use rustecal::{Ecal, EcalComponents, TypedSubscriber};
use rustecal_types_bytes::BytesMessage;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Ecal::initialize(Some("blob subscriber"), EcalComponents::DEFAULT, None)?;

    let mut subscriber = TypedSubscriber::&lt;BytesMessage&gt;::new("blob")?;
    subscriber.set_callback(|message| {
        println!("Received blob of {} bytes", message.payload.data.len());
    });

    while Ecal::ok() {
        std::thread::sleep(std::time::Duration::from_millis(500));
    }

    Ecal::finalize();
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-message-example"><a class="header" href="#string-message-example">String Message Example</a></h1>
<h2 id="publisher-1"><a class="header" href="#publisher-1">Publisher</a></h2>
<pre><pre class="playground"><code class="language-rust">use rustecal::{Ecal, EcalComponents, TypedPublisher};
use rustecal::pubsub::publisher::Timestamp;
use rustecal_types_string::StringMessage;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Ecal::initialize(Some("string publisher"), EcalComponents::DEFAULT, None)?;

    let publisher = TypedPublisher::&lt;StringMessage&gt;::new("hello")?;

    while Ecal::ok() {
        let message = StringMessage { data: "Hello from Rust".into() };
        publisher.send(&amp;message, Timestamp::Auto);

        std::thread::sleep(std::time::Duration::from_millis(500));
    }

    Ecal::finalize();
    Ok(())
}</code></pre></pre>
<h2 id="subscriber-1"><a class="header" href="#subscriber-1">Subscriber</a></h2>
<pre><pre class="playground"><code class="language-rust">use rustecal::{Ecal, EcalComponents, TypedSubscriber};
use rustecal_types_string::StringMessage;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Ecal::initialize(Some("string subscriber"), EcalComponents::DEFAULT, None)?;

    let mut subscriber = TypedSubscriber::&lt;StringMessage&gt;::new("hello")?;
    subscriber.set_callback(|message| {
        println!("Received: {}", message.payload.data)
    });

    while Ecal::ok() {
        std::thread::sleep(std::time::Duration::from_millis(500));
    }

    Ecal::finalize();
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protobuf-message-example"><a class="header" href="#protobuf-message-example">Protobuf Message Example</a></h1>
<h2 id="publisher-2"><a class="header" href="#publisher-2">Publisher</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::sync::Arc;
use rustecal::{Ecal, EcalComponents, TypedPublisher};
use rustecal::pubsub::publisher::Timestamp;
use rustecal_types_protobuf::{ProtobufMessage, IsProtobufType};

mod people      { include!(concat!(env!("OUT_DIR"), "/pb.people.rs")); }
mod animal      { include!(concat!(env!("OUT_DIR"), "/pb.animal.rs")); }
mod environment { include!(concat!(env!("OUT_DIR"), "/pb.environment.rs")); }

use people::Person;
impl IsProtobufType for Person {}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Ecal::initialize(Some("protobuf publisher"), EcalComponents::DEFAULT, None)?;

    let publisher = TypedPublisher::&lt;ProtobufMessage&lt;Person&gt;&gt;::new("person")?;

    while Ecal::ok() {
        let person = Person { id: 1, name: "Alice".into(), ..Default::default() };

        let message = ProtobufMessage { data : Arc::from(person) };
        publisher.send(&amp;message, Timestamp::Auto);

        std::thread::sleep(std::time::Duration::from_millis(500));
    }

    Ecal::finalize();
    Ok(())
}</code></pre></pre>
<h2 id="subscriber-2"><a class="header" href="#subscriber-2">Subscriber</a></h2>
<pre><pre class="playground"><code class="language-rust">use rustecal::{Ecal, EcalComponents, TypedSubscriber};
use rustecal_types_protobuf::{ProtobufMessage, IsProtobufType};

mod people      { include!(concat!(env!("OUT_DIR"), "/pb.people.rs")); }
mod animal      { include!(concat!(env!("OUT_DIR"), "/pb.animal.rs")); }
mod environment { include!(concat!(env!("OUT_DIR"), "/pb.environment.rs")); }

use people::Person;
impl IsProtobufType for Person {}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Ecal::initialize(Some("protobuf subscriber"), EcalComponents::DEFAULT, None)?;

    let mut subscriber = TypedSubscriber::&lt;ProtobufMessage&lt;Person&gt;&gt;::new("person")?;
    subscriber.set_callback(|message| {
        println!("Received person: {}", message.payload.data.name)
    });

    while Ecal::ok() {
        std::thread::sleep(std::time::Duration::from_millis(500));
    }

    Ecal::finalize();
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-message-example"><a class="header" href="#json-message-example">JSON Message Example</a></h1>
<h2 id="publisher-3"><a class="header" href="#publisher-3">Publisher</a></h2>
<pre><pre class="playground"><code class="language-rust">use serde::{Serialize, Deserialize};
use rustecal::{Ecal, EcalComponents, TypedPublisher};
use rustecal::pubsub::publisher::Timestamp;
use rustecal_types_serde::JsonMessage;

#[derive(Serialize, Deserialize, Clone, Debug)]
struct MyData {
    msg: String,
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Ecal::initialize(Some("json publisher"), EcalComponents::DEFAULT, None)?;

    let publisher = TypedPublisher::&lt;JsonMessage&lt;MyData&gt;&gt;::new("hello_json")?;

    while Ecal::ok() {
        let payload = MyData { msg: "Hello from Rust".into() };
        let message = JsonMessage::new(payload);
        publisher.send(&amp;message, Timestamp::Auto);

        std::thread::sleep(std::time::Duration::from_millis(500));
    }

    Ecal::finalize();
    Ok(())
}</code></pre></pre>
<h2 id="subscriber-3"><a class="header" href="#subscriber-3">Subscriber</a></h2>
<pre><pre class="playground"><code class="language-rust">use serde::{Serialize, Deserialize};
use rustecal::{Ecal, EcalComponents, TypedSubscriber};
use rustecal_types_serde::JsonMessage;

#[derive(Serialize, Deserialize, Clone, Debug)]
struct MyData {
    msg: String,
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Ecal::initialize(Some("json subscriber"), EcalComponents::DEFAULT, None)?;

    let mut subscriber = TypedSubscriber::&lt;JsonMessage&lt;MyData&gt;&gt;::new("hello_json")?;
    subscriber.set_callback(|message| {
        println!("Received: {}", message.payload.data.msg);
    });

    while Ecal::ok() {
        std::thread::sleep(std::time::Duration::from_millis(500));
    }

    Ecal::finalize();
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-server-example"><a class="header" href="#service-server-example">Service Server Example</a></h1>
<p>This example shows how to implement a basic <strong>Mirror Service Server</strong> using <code>rustecal</code>.</p>
<p>The server receives a request, logs it, and sends it back as a response.</p>
<h2 id="example-code"><a class="header" href="#example-code">Example Code</a></h2>
<pre><pre class="playground"><code class="language-rust">use rustecal::{Ecal, EcalComponents, ServiceServer};
use rustecal::service::types::MethodInfo;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Ecal::initialize(Some("mirror_server"), EcalComponents::DEFAULT, None)?;

    let mut server = ServiceServer::new("mirror_service")?;

    server.add_method("mirror", Box::new(|method: MethodInfo, req: &amp;[u8]| {
        let request_str = String::from_utf8_lossy(req);
        println!("Received [{}] request: {}", method.method_name, request_str);

        // Echo (mirror) the same bytes back
        req.to_vec()
    }))?;

    println!("mirror_service is running…");

    while Ecal::ok() {
        std::thread::sleep(std::time::Duration::from_millis(500));
    }

    Ecal::finalize();
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-client-example"><a class="header" href="#service-client-example">Service Client Example</a></h1>
<p>This example demonstrates how to call a <strong>Mirror Service</strong> using <code>rustecal</code>.</p>
<h2 id="example-code-1"><a class="header" href="#example-code-1">Example Code</a></h2>
<pre><pre class="playground"><code class="language-rust">use rustecal::{Ecal, EcalComponents, ServiceClient, ServiceRequest};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Ecal::initialize(Some("mirror_client"), EcalComponents::DEFAULT, None)?;

    let client = ServiceClient::new("mirror_service")?;

    let request_data = b"Hello, Service!";
    let timeout = Some(500);

    while Ecal::ok() {
        let request = ServiceRequest {
            payload: request_data.to_vec(),
        };

        // Call the "mirror" method
        if let Some(response) = client.call("mirror", request, timeout) {
            // Extract the echoed payload
            let echoed = String::from_utf8_lossy(&amp;response.payload);
            println!("Received response: {}", echoed);
        } else {
            println!("Service call timed out.");
        }

        std::thread::sleep(std::time::Duration::from_millis(500));
    }

    Ecal::finalize();
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monitoring-snapshot"><a class="header" href="#monitoring-snapshot">Monitoring Snapshot</a></h1>
<p>This example demonstrates how to continuously poll the eCAL runtime for a <strong>monitoring snapshot</strong> using the <code>Monitoring::get_snapshot()</code> API.</p>
<pre><pre class="playground"><code class="language-rust">use rustecal::{Ecal, EcalComponents};
use rustecal_core::monitoring::Monitoring;
use std::{thread, time::Duration};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize only the monitoring subsystem
    Ecal::initialize(Some("monitoring_receive_sample"), EcalComponents::MONITORING, None)?;

    while Ecal::ok() {
        let snap = Monitoring::get_snapshot()?;

        println!("=== Monitoring Snapshot ===\n");
        println!("Processes:\n{:#?}", snap.processes);
        println!("\nPublishers:\n{:#?}", snap.publishers);
        println!("\nSubscribers:\n{:#?}", snap.subscribers);
        println!("\nServers:\n{:#?}", snap.servers);
        println!("\nClients:\n{:#?}", snap.clients);

        thread::sleep(Duration::from_secs(1));
    }

    Ecal::finalize();
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging-snapshot"><a class="header" href="#logging-snapshot">Logging Snapshot</a></h1>
<p>This example demonstrates how to continuously poll the eCAL runtime for <strong>log messages</strong> using the <code>Log::get_logging()</code> API.</p>
<pre><pre class="playground"><code class="language-rust">use rustecal::{Ecal, EcalComponents};
use rustecal_core::log::Log;
use std::{thread, time::Duration};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize only the logging subsystem
    Ecal::initialize(Some("logging_receive_sample"), EcalComponents::LOGGING, None)?;

    while Ecal::ok() {
        let entries = Log::get_logging()?;
        println!("=== Logging Snapshot ===\n");
        println!("Entries:\n{:#?}", entries);

        thread::sleep(Duration::from_secs(1));
    }

    Ecal::finalize();
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h1>
<p>Welcome to the <code>rustecal</code> API documentation. This section provides an overview of the main types and traits used to interact with the eCAL communication system through safe and idiomatic Rust APIs.</p>
<p>Explore the individual components in detail:</p>
<ul>
<li><a href="api/./ecal.html">Ecal Lifecycle</a></li>
<li><a href="api/./message_types.html">Supported Message Types</a></li>
<li><a href="api/./publisher.html">Typed Publisher</a></li>
<li><a href="api/./subscriber.html">Typed Subscriber</a></li>
<li><a href="api/./zero_copy_messaging.html">Zero Copy Messaging</a></li>
<li><a href="api/./service_server.html">Service Server</a></li>
<li><a href="api/./service_client.html">Service Client</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecal-lifecycle"><a class="header" href="#ecal-lifecycle">Ecal Lifecycle</a></h1>
<p>The <code>Ecal</code> struct manages initialization and finalization of the eCAL system.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use rustecal::{Ecal, EcalComponents};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Ecal::initialize(Some("my ecal app"), EcalComponents::DEFAULT, None)?;

    // use publishers, subscribers, clients, server

    Ecal::finalize();
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typed-publisher"><a class="header" href="#typed-publisher">Typed Publisher</a></h1>
<p>The <code>Publisher&lt;T&gt;</code> allows you to publish messages of type <code>T</code> on a topic.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustecal::{Ecal, EcalComponents, TypedPublisher};
use rustecal::pubsub::publisher::Timestamp;
use rustecal_types_string::StringMessage;

let publisher = TypedPublisher::&lt;StringMessage&gt;::new("hello").unwrap();

let message = StringMessage { data: "Hello from Rust".into() }
publisher.send(&amp;message, Timestamp::Auto);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typed-subscriber"><a class="header" href="#typed-subscriber">Typed Subscriber</a></h1>
<p>The <code>Subscriber&lt;T&gt;</code> enables you to subscribe to messages of type <code>T</code> on a topic.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustecal::{Ecal, EcalComponents, TypedSubscriber};
use rustecal_types_string::StringMessage;

let mut subscriber = TypedSubscriber::&lt;StringMessage&gt;::new("hello")?;
subscriber.set_callback(|message| {
    println!("Received: {}", message.payload.data)
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supported-message-types-1"><a class="header" href="#supported-message-types-1">Supported Message Types</a></h1>
<p><code>rustecal</code> supports message types through wrapper structs:</p>
<h2 id="stringmessage"><a class="header" href="#stringmessage"><code>StringMessage</code></a></h2>
<p>Used for UTF-8 string topics.</p>
<h2 id="bytesmessage"><a class="header" href="#bytesmessage"><code>BytesMessage</code></a></h2>
<p>Used for binary <code>Vec&lt;u8&gt;</code> payloads.</p>
<h2 id="protobufmessaget"><a class="header" href="#protobufmessaget"><code>ProtobufMessage&lt;T&gt;</code></a></h2>
<p>Supports publishing/receiving of Protobuf types that implement <code>Message</code> and <code>Default</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustecal_types_protobuf::{ProtobufMessage, IsProtobufType};

use people::Person;
impl IsProtobufType for Person {}

let publisher = TypedPublisher::&lt;ProtobufMessage&lt;Person&gt;&gt;::new("person").unwrap();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecal-zero-copy-in-rustecal"><a class="header" href="#ecal-zero-copy-in-rustecal">eCAL Zero-Copy in Rustecal</a></h1>
<p>This guide shows you how to publish and receive large binary payloads <strong>without any memcpy</strong> by using:</p>
<ul>
<li><strong><code>TypedPublisher&lt;BytesMessage&gt;</code></strong> - a built-in byte-array message type</li>
<li><strong><code>PayloadWriter</code></strong> - for direct in-place writes into eCAL's shared memory</li>
</ul>
<hr />
<h2 id="1-how-ecal-zero-copy-works"><a class="header" href="#1-how-ecal-zero-copy-works">1. How eCAL Zero-Copy Works</a></h2>
<p>eCAL zero-copy uses shared memory to avoid copying data between publisher and subscriber.</p>
<ul>
<li><strong>Publisher</strong> allocates a memory file and writes directly into it via <code>PayloadWriter</code>.</li>
<li><strong>Subscriber</strong> maps the same memory file and reads the buffer in place.</li>
<li>Handshake and buffer management are handled by eCAL's SHM layer.</li>
</ul>
<hr />
<h2 id="2-payloadwriter-api"><a class="header" href="#2-payloadwriter-api">2. <code>PayloadWriter</code> API</a></h2>
<p>A <code>PayloadWriter</code> lets you fill the shared-memory buffer in place:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait PayloadWriter {
    /// Called once on first allocation or resize.
    fn write_full(&amp;mut self, buf: &amp;mut [u8]) -&gt; bool;

    /// Called on subsequent sends to modify only parts of the buffer.
    fn write_modified(&amp;mut self, buf: &amp;mut [u8]) -&gt; bool {
        self.write_full(buf)
    }

    /// Returns the exact number of bytes you will write.
    fn get_size(&amp;self) -&gt; usize;
}
<span class="boring">}</span></code></pre></pre>
<p>Implement these methods for your payload type, then pass a mutable reference to <code>send_payload_writer</code>.</p>
<hr />
<h2 id="3-publisher-sample"><a class="header" href="#3-publisher-sample">3. Publisher Sample</a></h2>
<pre><pre class="playground"><code class="language-rust">use rustecal::{Configuration, Ecal, EcalComponents, TypedPublisher};
use rustecal_pubsub::PayloadWriter;
use rustecal_pubsub::publisher::Timestamp;
use rustecal_types_bytes::BytesMessage;

/// A simple zero-copy writer that fills a buffer with a repeating pattern.
pub struct CustomWriter {
    size: usize,
    counter: u8,
}

impl CustomWriter {
    pub fn new(size: usize) -&gt; Self {
        Self { size, counter: 0 }
    }
}

impl PayloadWriter for CustomWriter {
    fn write_full(&amp;mut self, buf: &amp;mut [u8]) -&gt; bool {
        if buf.len() &lt; self.size { return false; }
        // fill entire buffer with 0xAA
        buf[..self.size].fill(0xAA);
        true
    }

    fn write_modified(&amp;mut self, buf: &amp;mut [u8]) -&gt; bool {
        if buf.len() &lt; self.size { return false; }
        // flip one byte each time
        let idx = (self.counter as usize) % self.size;
        buf[idx] ^= 0xFF;
        self.counter = self.counter.wrapping_add(1);
        true
    }

    fn get_size(&amp;self) -&gt; usize {
        self.size
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // configure eCAL
    let mut cfg = Configuration::new()?;
    cfg.publisher.layer.shm.zero_copy_mode         = true as i32;
    cfg.publisher.layer.shm.acknowledge_timeout_ms = 50;
    Ecal::initialize(
        Some("zero copy publisher"),
        EcalComponents::DEFAULT,
        Some(&amp;cfg),
    )?;

    // create typed publisher
    let publisher: TypedPublisher&lt;BytesMessage&gt; =
        TypedPublisher::new("buffer")?;

    // prepare zero-copy payload writer
    let mut writer = CustomWriter::new(8 * 1024 * 1024); // 8 MB

    // send loop
    while Ecal::ok() {
        publisher.send_payload_writer(&amp;mut writer, Timestamp::Auto);
    }

    // finalize ecal and clean up
    Ecal::finalize();
    Ok(())
}</code></pre></pre>
<hr />
<h2 id="4-subscriber-sample"><a class="header" href="#4-subscriber-sample">4. Subscriber Sample</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::{thread, time::Duration};
use rustecal::{Ecal, EcalComponents, TypedSubscriber};
use rustecal_types_bytes::BytesMessage;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // initialize eCAL
    Ecal::initialize(
        Some("zero copy subscriber"),
        EcalComponents::DEFAULT,
        None,
    )?;

    // create typed subscriber
    let mut sub: TypedSubscriber&lt;BytesMessage&gt; =
        TypedSubscriber::new("buffer")?;

    // register zero-copy callback
    sub.set_callback(|received| {
        // borrow shared-memory payload
        let buffer: &amp;[u8] = received.payload.data.as_ref();
        // this line is just to demonstrate usage (it will kill the performance)
        println!("Received {} bytes", buffer.len());
    });

    // keep alive for callbacks
    while Ecal::ok() {
        thread::sleep(Duration::from_millis(100));
    }

    // finalize ecal and clean up
    Ecal::finalize();
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-server"><a class="header" href="#service-server">Service Server</a></h1>
<p>The <code>ServiceServer</code> API allows Rust applications to act as eCAL service providers using a simple, callback-based interface that mirrors the C++ and C APIs.</p>
<h2 id="registering-methods"><a class="header" href="#registering-methods">Registering Methods</a></h2>
<p>To provide services, create a <code>ServiceServer</code> and register one or more methods by name:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustecal::service::server::ServiceServer;
use rustecal::service::types::MethodInfo;

let mut server = ServiceServer::new("mirror")?;

server.add_method("echo", Box::new(|_info: MethodInfo, request: &amp;[u8]| {
    request.to_vec()
}))?;

server.add_method("reverse", Box::new(|_info, request| {
    let mut reversed = request.to_vec();
    reversed.reverse();
    reversed
}))?;
<span class="boring">}</span></code></pre></pre>
<h2 id="method-signatures"><a class="header" href="#method-signatures">Method Signatures</a></h2>
<p>The callback signature follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Fn(MethodInfo, &amp;[u8]) -&gt; Vec&lt;u8&gt;
<span class="boring">}</span></code></pre></pre>
<p>This is safe, allocation-free on the input side, and flexible for any binary or textual payloads.</p>
<h2 id="example-output"><a class="header" href="#example-output">Example Output</a></h2>
<pre><code>Method   : 'echo' called
Request  : stressed
Response : stressed

Method   : 'reverse' called
Request  : stressed
Response : desserts
</code></pre>
<h2 id="runtime-compatibility"><a class="header" href="#runtime-compatibility">Runtime Compatibility</a></h2>
<p>This API is fully compatible with the C++ <code>mirror_server.cpp</code>, the C <code>mirror_server_c.c</code> and the C# <code>mirror_client_csharp.cs</code> example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-client"><a class="header" href="#service-client">Service Client</a></h1>
<p>The <code>ServiceClient</code> API allows a Rust application to call eCAL services, either generically or per-instance.</p>
<h2 id="connecting-to-a-service"><a class="header" href="#connecting-to-a-service">Connecting to a Service</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustecal::service::client::ServiceClient;

let client = ServiceClient::new("mirror")?;
<span class="boring">}</span></code></pre></pre>
<h2 id="calling-methods"><a class="header" href="#calling-methods">Calling Methods</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustecal::service::types::ServiceRequest;

let request = ServiceRequest {
    payload: b"stressed".to_vec(),
};
<span class="boring">}</span></code></pre></pre>
<p>To broadcast call all connected instances:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let responses = client.call("echo", request, Some(1000));
<span class="boring">}</span></code></pre></pre>
<p>To call (and filter) all connected instances separately:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for instance in client.get_client_instances() {
    let response = instance.call("reverse", request.clone(), Some(1000));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="return-handling"><a class="header" href="#return-handling">Return Handling</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match response {
    Some(res) if res.success =&gt; {
        println!("Response: {}", String::from_utf8_lossy(&amp;res.payload));
    }
    Some(res) =&gt; {
        println!("Error: {}", res.error_msg.unwrap_or("Unknown error".into()));
    }
    None =&gt; {
        println!("No response or timeout.");
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="runtime-compatibility-1"><a class="header" href="#runtime-compatibility-1">Runtime Compatibility</a></h2>
<p>This API is fully compatible with the C++ <code>mirror_client.cpp</code>, the C <code>mirror_client_c.c</code> and the C# <code>mirror_client_csharp.cs</code> example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h1>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Cross-platform support (Windows, Linux)</li>
<li><input disabled="" type="checkbox" checked=""/>
Safe API for initialization, shutdown</li>
<li><input disabled="" type="checkbox" checked=""/>
Binary publish/subscribe API</li>
<li><input disabled="" type="checkbox" checked=""/>
Typed publish/subscribe API</li>
<li><input disabled="" type="checkbox" checked=""/>
Modular type crates (string, bytes, protobuf, serde (json/cbor/msgpack))</li>
<li><input disabled="" type="checkbox" checked=""/>
Binary server/client API</li>
<li><input disabled="" type="checkbox" checked=""/>
Examples for all publish/subscribe and client/server</li>
<li><input disabled="" type="checkbox" checked=""/>
Monitoring and logging support</li>
<li><input disabled="" type="checkbox"/>
Protobuf descriptor introspection</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about"><a class="header" href="#about">About</a></h1>
<p>Created by Rex Schilasky<br />
🚗 Automotive | 🧠 SDV | 🛠️ Rust | 🚀 IPC</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Licensed under the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
